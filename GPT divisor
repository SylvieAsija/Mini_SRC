module restoring_division(
    input [31:0] dividend,
    input [31:0] divisor,
    output [63:0] quotient,
    output [31:0] remainder
);

reg [31:0] quotient_reg;
reg [31:0] remainder_reg;
reg [31:0] divisor_reg;
reg [31:0] temp;
reg sign;
integer i;

always @(*) begin
    sign = 0; // initialize sign bit
    if (dividend[31] ^ divisor[31]) // check if the signs are different
        sign = 1; // set sign bit if signs are different
    divisor_reg = divisor; // load divisor into register
    remainder_reg = dividend; // load dividend into register
    quotient_reg = 0; // initialize quotient
    for (i = 0; i < 32; i = i + 1) begin
        temp = remainder_reg;
        if (temp[31] == 1 || temp >= divisor_reg) begin
            quotient_reg[i] = 1; // set quotient bit
            remainder_reg = temp - divisor_reg; // update remainder
        end
        divisor_reg = divisor_reg >> 1; // shift divisor right by 1
    end
end

assign quotient = { {32{sign}}, quotient_reg }; // sign extend quotient to 64 bits
assign remainder = remainder_reg;

endmodule
